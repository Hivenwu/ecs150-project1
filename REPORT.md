The project is consisted of 8 phases and implementation and design choices for each stages are explained below:

Phase 2:read commands from the input
In my implementation I used getline() inside a while(1) loop to reapeately receive input from users. The userinput 

Phase 3:arguments
A command/argument sturct array is implemented to store the user input each element of the struct array representing a single command. The parsing of the command is done with a single iteration on the userinput and it is completed in linear time, and various string functions from the string library such as strcpy() and strcmp() and strtok() are used to help the program parse the user input string and store the corresponsing information into the command sturct. The fields of the structure array contains an integer named argc which represents the total number of arguments for a particular command and it is paired with char** agrs, an array of characters which are used to stored both the command and the argument of user-input.In args, args[0] represents the user command and the rest of elements in args represent each one of the arguments included with the command.  For example if the user-input is "echo dog",the string "echo" will get stored inside args[0] and "dog" stroed inside args[1].I choose to store these information as array of strings inside a struct inorder to use it as the second argument for the essential execv function without having to stored them in another 2D char seperately and later in the program.

Phase 4:buildin commands
Since both "exit" and "cd" as well as "pwd" are considered to be buildin commands that can be executed in the main processs without forking any childs, various system functions that include getcwd() and chdir() and exit are used to help directly execute these buildin commands. I put these functions inside the user created function external_modsys() and it will get executed whenever the program detects these buildin commands from user-input.

Phase 5:Input redirection
I implemented the input redirection by first open the file specified in the user input and use syscall dup2(userfile,STDIN_FILENO) to duplicate the opened user file descirptor into the default stdin file descriptor. Next, the program futher modifies the already parsed user input struct by ignoring and cutting out every string that appears after the redirection character '>' or '<' to make sure that the execv function accepts the correct argument. For example, if the user's input is "grep tree < filename", only the string array {"grep","tree"} will be maintained after the trimming process and passed into execv with all the characters contained inside the file being passed to the terminal as input.

Phase 6:Output redirection
The implementation for output redirection functions in some ways similar to that of input redirection with dup2(userfile,STDOUT_FILENO) being utilized again and copying the opened user file descriptor onto the defalut standard output file descirptor. The same trimming procedure is used to modify the user input structure by cutting out all the strings that appears after the redirection character '>' or '<. The modifed user input structure will then get pass into the execv function and the output of the program will get written into the designated user file.

Phase 7:Pipeline commands
Pipeline commands in this project can be implemented in various ways, and my design is consisted of utitlizing a for loop that forks multiple child process with all of them sharing the same parent process which is the main process. A total of n-1 pipes are created and piped in the main process with n child processes representing n piped user commands. Inside the for loop a combination of orintations of system functions such as dup2() and close() are used to to create pipe connections between child processes by carefully connecting , and a total of three distinct cases are considered in the implementation with them being the initial piped command, the last command in the pipline, and the ones between them. No wait functions are included inside the for loop of the main/parent process since the main process are responsibled for forking multiple childs inside the for loop, and also since each external commands being called by execv will wait for input before proceeds to execution and there is no need to wait for them. However, during each iteration and each encounter with the parent process, the PID of its child process is stored into an interger array of the same as the total number of user commands called called the pid_array to be used at the end of the function call to wait for all the child processes. All of the opened and unused file descriptors are also closed to prevent the shell from hanging due to empty output from the pipe.At the end of the pipeline function another for loop is executed onto the pid_array and waitpid(pid_array[i],&status,0) is called sequentially to wait for each of the child process to terminate befoe returning the function and go back to receive user input. Also, both input and output redirection commands are checked in the begining and the end of the pipline along with the background commands being checked at the end of the pipeline.

Phase 8:Background commands:
Background commands are implemented by 


